package entpb

import (
	"cmp"
	"errors"
	"fmt"
	"slices"
	"strings"

	"entgo.io/ent/entc/gen"
	"entgo.io/ent/entc/load"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/field"
	"github.com/iancoleman/strcase"
	"github.com/lesomnus/entpb/pbgen"
	"github.com/lesomnus/entpb/pbgen/ident"
	"github.com/lesomnus/entpb/utils"
)

type Build struct {
	// Filepath or alias to proto file to be output.
	Files map[string]*ProtoFile

	// Key is a global name of the Go type that bound to enum.
	// e.g. for enum "Role" that bound to Go type "Role" in package "github.com/lesomnus/entpb/example",
	// the key would be its global name, "github.com/lesomnus/entpb/example:example.Role".
	// Global name can be built using following functions:
	//   - utils.FullIdent
	//   - utils.FullIdentFromReflect
	//   - utils.FullIdentFromEntTypeInfo
	Enums map[string]*Enum

	// Holds message definitions.
	// Key is name of message.
	// e.g. User, GetUserRequest, Identity, ...
	Messages map[ident.Ident]*MessageAnnotation

	// Messages defined by Ent schema.
	Schemas map[string]*MessageAnnotation
}

func NewBuild(graph *gen.Graph) (*Build, error) {
	b := &Build{
		Files:    map[string]*ProtoFile{},
		Enums:    map[string]*Enum{},
		Messages: map[ident.Ident]*MessageAnnotation{},
		Schemas:  map[string]*MessageAnnotation{},
	}
	if err := b.parse(graph); err != nil {
		return nil, err
	}

	return b, nil
}

func (b *Build) parse(graph *gen.Graph) error {
	if d, ok := DecodeAnnotation(&ProtoFiles{}, graph.Annotations); !ok {
		return nil
	} else {
		for p, f := range *d {
			for name, enum := range f.Enums {
				if _, ok := b.Enums[name]; ok {
					return fmt.Errorf(`multiple definition of enum for same Go type "%s"`, name)
				}

				enum.File = f
				b.Enums[name] = enum
			}

			f.Filepath = p
			f.Imports = map[string]struct{}{}
			b.Files[p] = f
		}
	}

	errs := []error{}
	for _, s := range graph.Schemas {
		// Note that `parseMessage` does not parse their fields but only its name
		// since there may be dependencies between messages.
		if err := b.parseMessage(s); err != nil {
			errs = append(errs, fmt.Errorf(`schema "%s": %w`, s.Name, err))
			continue
		}
	}
	if len(errs) > 0 {
		return fmt.Errorf("parse messages declarations: %w", errors.Join(errs...))
	}

	errs = []error{}
	for _, enum := range b.Enums {
		if err := b.normalizeEnum(enum); err != nil {
			errs = append(errs, fmt.Errorf(`normalize enum "%s": %w`, enum.Ident, err))
		}
	}
	for _, msg := range b.Schemas {
		if err := b.parseFields(msg); err != nil {
			errs = append(errs, fmt.Errorf(`parse fields: %w`, err))
		}
	}
	// Service must be parsed after the fields are parsed
	// since messaged generated while in service generation
	// has dependency across multiple messages generated by schema.
	for _, msg := range b.Schemas {
		if err := b.parseService(msg); err != nil {
			errs = append(errs, fmt.Errorf(`parse service: %w`, err))
		}
	}
	if len(errs) > 0 {
		return fmt.Errorf("parse message definitions: %w", errors.Join(errs...))
	}

	errs = []error{}
	// Rpcs must be parsed after the services are parsed
	// since some rpc generates a message that bound to another message (e.g. GetEntityRequest),
	// so it references service.File to put the generated file in the index.
	for _, msg := range b.Schemas {
		if err := b.parseServiceRpcs(msg); err != nil {
			errs = append(errs, fmt.Errorf(`parse rpcs in %s: %w`, msg.Ident, err))
		}
	}
	if len(errs) > 0 {
		return errors.Join(errs...)
	}

	return nil
}

func (b *Build) parseMessage(r *load.Schema) error {
	d, ok := DecodeAnnotation(&MessageAnnotation{}, r.Annotations)
	if !ok {
		return nil
	}
	if d.Ident == "" {
		d.Ident = ident.Ident(r.Name)
	}
	if a, ok := DecodeAnnotation(&schema.CommentAnnotation{}, r.Annotations); ok {
		d.Comment = a.Text
	}

	f, ok := b.Files[d.Filepath]
	if !ok {
		return fmt.Errorf(`message "%s" references non-exists proto file "%s"`, d.Ident, d.Filepath)
	}

	if _, ok := f.Messages[d.Ident]; ok {
		return fmt.Errorf(`message name "%s" duplicated with proto file "%s"`, d.Ident, d.Filepath)
	}

	d.File = f
	d.Schema = r
	f.Messages[d.Ident] = d
	b.Messages[d.Ident] = d
	b.Schemas[r.Name] = d
	return nil
}

func (p *Build) normalizeEnum(enum *Enum) error {
	prefix := ""
	has_zero := false
	if enum.Prefix == nil {
		// no prefix
	} else if *enum.Prefix == "" {
		prefix = fmt.Sprintf("%s_", enum.Ident)
	} else {
		prefix = fmt.Sprintf("%s_", *enum.Prefix)
	}

	for _, v := range enum.Fields {
		if v.Number == 0 {
			has_zero = true
			break
		}
	}
	if !enum.IsClosed && !has_zero {
		enum.Fields = append(enum.Fields, &EnumField{
			Number: 0,
			Value:  "Unspecified",
		})
	}
	for _, v := range enum.Fields {
		name := fmt.Sprintf("%s%s", prefix, v.Value)
		name = strcase.ToSnake(name)
		name = strings.ToUpper(name)
		v.Name = name
	}

	return nil
}

func (b *Build) parseFields(m *MessageAnnotation) error {
	errs := []error{}
	for _, field := range m.Schema.Fields {
		d, err := b.parseEntField(field)
		if err != nil {
			errs = append(errs, fmt.Errorf(`field "%s": %w`, field.Name, err))
			continue
		}
		if d == nil {
			continue
		}

		m.Fields = append(m.Fields, d)
	}

	edges := slices.Clone(m.Schema.Edges)
	for _, edge := range m.Schema.Edges {
		if edge.Ref == nil {
			continue
		}
		if edge.Ref.Type == edge.Type {
			edges = append(edges, edge.Ref)
		}
	}
	for _, edge := range edges {
		d, err := b.parseEntEdge(edge)
		if err != nil {
			errs = append(errs, fmt.Errorf(`edge "%s": %w`, edge.Name, err))
			continue
		}
		if d == nil {
			continue
		}

		m.Fields = append(m.Fields, d)
	}

	if len(errs) > 0 {
		return errors.Join(errs...)
	}

	return nil
}

func (p *Build) parseEntField(r *load.Field) (*FieldAnnotation, error) {
	d, ok := DecodeAnnotation(&FieldAnnotation{}, r.Annotations)
	if !ok {
		return nil, nil
	}
	if d.Ident == "" {
		d.Ident = ident.Ident(r.Name)
	}

	if r.Info.Type == field.TypeEnum {
		name := utils.FullIdentFromEntTypeInfo(r.Info)
		enum, ok := p.Enums[name]
		if !ok {
			return nil, fmt.Errorf(`unregistered enum type: "%s"`, name)
		}

		d.PbType = PbType{
			Ident:   enum.Ident,
			Package: enum.File.PbPackage,
			Import:  enum.File.Filepath,
		}
	} else if t := pb_types[int(r.Info.Type)]; t.Ident == "" {
		return nil, fmt.Errorf("unsupported type: %s", r.Info.Type.String())
	} else {
		d.PbType = t
	}

	d.Comment = r.Comment
	d.EntName = r.Name
	d.EntInfo = r.Info
	d.HasDefault = r.Default
	d.IsKey = r.Unique
	d.IsImmutable = r.Immutable
	d.IsOptional = r.Nillable

	return d, nil
}

func (p *Build) parseEntEdge(r *load.Edge) (*FieldAnnotation, error) {
	d, ok := DecodeAnnotation(&FieldAnnotation{}, r.Annotations)
	if !ok {
		return nil, nil
	}
	if d.Ident == "" {
		d.Ident = ident.Ident(r.Name)
	}

	message, ok := p.Schemas[r.Type]
	if !ok {
		return nil, fmt.Errorf(`references a schema "%s" that is not a proto message`, r.Type)
	}

	d.Comment = r.Comment
	d.EntName = r.Name
	d.EntMsg = message
	d.PbType = message.pbType()
	d.IsOptional = !r.Required
	d.IsRepeated = !r.Unique
	d.IsImmutable = r.Immutable

	return d, nil
}

func (p *Build) parseService(d *MessageAnnotation) error {
	s := d.Service
	if s == nil || len(s.Rpcs) == 0 {
		return nil
	}

	s.Message = d
	if s.Filepath == "" {
		s.Filepath = d.Filepath
	}

	f, ok := p.Files[s.Filepath]
	if !ok {
		return fmt.Errorf(`service "%s" references non-exists proto file "%s"`, d.Ident, s.Filepath)
	} else {
		s.File = f
	}
	if s.Ident == "" {
		s.Ident = ident.Ident(fmt.Sprintf("%sService", d.Ident))
	}
	if _, ok := f.Services[s.Ident]; ok {
		return fmt.Errorf(`duplicated service "%s"`, s.Ident)
	} else {
		f.Services[s.Ident] = s
	}

	return nil
}

func (p *Build) parseServiceRpcs(d *MessageAnnotation) error {
	s := d.Service

	for _, rpc := range s.Rpcs {
		switch rpc.Ident {
		case "Create":
			req_name := ident.Ident(fmt.Sprintf("Create%sRequest", d.Ident))
			rpc.Req = d.pbType()
			rpc.Req.Ident = req_name
			rpc.Res = d.pbType()

			msg := &MessageAnnotation{
				Filepath: s.Filepath,
				Ident:    req_name,
				File:     s.File,
				Schema:   d.Schema,
			}
			for _, field := range d.Fields {
				if field.IsReadOnly() {
					if field.HasDefault {
						// Set by server automatically.
						// e.g. Id, DateCreated
						continue
					}
					if !field.IsImmutable {
						// Set by creating reference resource.
						// e.g. User.Accounts set by creating Account.
						continue
					}

					// This field is read only and immutable
					// but doesn't have a default value,
					// so it can be set only when it is created.
				}
				if field.IsEdge() {
					ref_msg, ok := p.Schemas[field.EntMsg.Schema.Name]
					if !ok {
						return fmt.Errorf(`schema "%s" referenced by field "%s" does not exists`, field.EntMsg.Schema.Name, field.EntName)
					}

					v := *field
					get_msg := p.buildGetMessage(ref_msg)
					v.EntMsg = get_msg
					v.PbType = get_msg.pbType()
					msg.Fields = append(msg.Fields, &v)
					continue
				}
				if !field.HasDefault {
					msg.Fields = append(msg.Fields, field)
					continue
				}

				v := *field
				v.IsOptional = true
				msg.Fields = append(msg.Fields, &v)
			}

			s.File.Messages[req_name] = msg
			p.Messages[req_name] = msg

			rpc.EntReq = msg
			rpc.EntRes = d

			ps := getCreateRestPaths(msg)
			base := []pbgen.DataField{
				{Name: "post", Value: pbgen.DataString{Value: ps[0]}},
				{Name: "body", Value: pbgen.DataString{Value: "*"}},
			}
			extra := []pbgen.Data{}
			for _, p := range ps[1:] {
				extra = append(extra, pbgen.Data{Fields: []pbgen.DataField{
					{Name: "post", Value: pbgen.DataString{Value: p}},
					{Name: "body", Value: pbgen.DataString{Value: "*"}},
				}})
			}
			if len(extra) > 0 {
				base = append(base, pbgen.DataField{
					Name: "additional_bindings", Value: pbgen.DataList{Values: extra},
				})
			}

			rpc.Opts = []pbgen.Option{{
				Name:  ident.Must("google", "api", "http").WithBraces(),
				Value: pbgen.Data{Fields: base},
			}}

		case "Get":
			msg := p.buildGetMessage(d)

			rpc.Req = d.pbType()
			rpc.Req.Ident = msg.Ident
			rpc.Res = d.pbType()

			rpc.EntReq = msg
			rpc.EntRes = d

			ps := getSpecifierRestPaths(msg, "")
			base := []pbgen.DataField{
				{Name: "get", Value: pbgen.DataString{Value: ps[0]}},
			}
			extra := []pbgen.Data{}
			for _, p := range ps[1:] {
				extra = append(extra, pbgen.Data{Fields: []pbgen.DataField{
					{Name: "get", Value: pbgen.DataString{Value: p}},
				}})
			}
			if len(extra) > 0 {
				base = append(base, pbgen.DataField{
					Name: "additional_bindings", Value: pbgen.DataList{Values: extra},
				})
			}

			rpc.Opts = []pbgen.Option{{
				Name:  ident.Must("google", "api", "http").WithBraces(),
				Value: pbgen.Data{Fields: base},
			}}

		case "Update":
			req_name := ident.Ident(fmt.Sprintf("Update%sRequest", d.Ident))
			rpc.Req = d.pbType()
			rpc.Req.Ident = req_name
			rpc.Res = d.pbType()

			msg := &MessageAnnotation{
				Filepath: s.Filepath,
				Ident:    req_name,
				File:     s.File,
			}
			get_msg := p.buildGetMessage(d)
			for _, field := range d.Fields {
				if field.EntName == "id" {
					v := *field
					v.Ident = "key"
					v.EntMsg = get_msg
					v.PbType = get_msg.pbType()
					msg.Fields = append(msg.Fields, &v)
					continue
				}
				if field.IsImmutable || field.IsReadOnly() {
					continue
				}
				if field.IsEdge() {
					ref_msg, ok := p.Schemas[field.EntMsg.Schema.Name]
					if !ok {
						return fmt.Errorf(`schema "%s" referenced by field "%s" does not exists`, field.EntMsg.Schema.Name, field.EntName)
					}

					v := *field
					get_msg := p.buildGetMessage(ref_msg)
					v.EntMsg = get_msg
					v.PbType = get_msg.pbType()
					msg.Fields = append(msg.Fields, &v)
					continue
				}

				v := *field
				v.IsOptional = true
				msg.Fields = append(msg.Fields, &v)
			}

			s.File.Messages[req_name] = msg
			p.Messages[req_name] = msg

			rpc.EntReq = msg
			rpc.EntRes = d

			ps := getSpecifierRestPaths(get_msg, "key")
			base := []pbgen.DataField{
				{Name: "patch", Value: pbgen.DataString{Value: ps[0]}},
				{Name: "body", Value: pbgen.DataString{Value: "*"}},
			}
			extra := []pbgen.Data{}
			for _, p := range ps[1:] {
				extra = append(extra, pbgen.Data{Fields: []pbgen.DataField{
					{Name: "patch", Value: pbgen.DataString{Value: p}},
					{Name: "body", Value: pbgen.DataString{Value: "*"}},
				}})
			}
			if len(extra) > 0 {
				base = append(base, pbgen.DataField{
					Name: "additional_bindings", Value: pbgen.DataList{Values: extra},
				})
			}

			rpc.Opts = []pbgen.Option{{
				Name:  ident.Must("google", "api", "http").WithBraces(),
				Value: pbgen.Data{Fields: base},
			}}

		case "Delete":
			msg := p.buildGetMessage(d)

			rpc.Req = d.pbType()
			rpc.Req.Ident = msg.Ident
			rpc.Res = PbEmpty

			rpc.EntReq = msg
			rpc.EntRes = d

			ps := getSpecifierRestPaths(msg, "")
			base := []pbgen.DataField{
				{Name: "delete", Value: pbgen.DataString{Value: ps[0]}},
			}
			extra := []pbgen.Data{}
			for _, p := range ps[1:] {
				extra = append(extra, pbgen.Data{Fields: []pbgen.DataField{
					{Name: "delete", Value: pbgen.DataString{Value: p}},
				}})
			}
			if len(extra) > 0 {
				base = append(base, pbgen.DataField{
					Name: "additional_bindings", Value: pbgen.DataList{Values: extra},
				})
			}

			rpc.Opts = []pbgen.Option{{
				Name:  ident.Must("google", "api", "http").WithBraces(),
				Value: pbgen.Data{Fields: base},
			}}

		default:
			r := strings.NewReplacer(PbThis.Import, string(d.pbType().Ident))
			rpc.Req.Ident = ident.Ident(r.Replace(string(rpc.Req.Ident)))
			rpc.Res.Ident = ident.Ident(r.Replace(string(rpc.Res.Ident)))
			r = strings.NewReplacer(PbThis.Import, d.pbType().Import)
			rpc.Req.Import = r.Replace(rpc.Req.Import)
			rpc.Res.Import = r.Replace(rpc.Res.Import)

			if rpc.Req.Import == "" {
				return fmt.Errorf(`RPC "%s": parameter type must be message`, rpc.Ident)
			}
			if rpc.Res.Import == "" {
				return fmt.Errorf(`RPC "%s": return type must be message`, rpc.Ident)
			}
		}
	}

	return nil
}

func (p *Build) buildGetMessage(d *MessageAnnotation) *MessageAnnotation {
	s := d.Service
	if s == nil {
		panic(fmt.Sprintf("message \"%s\" does not have service definition", d.Ident))
	}

	req_name := ident.Ident(fmt.Sprintf("Get%sRequest", d.Ident))
	msg, ok := p.Messages[req_name]
	if ok {
		return msg
	}

	msg = &MessageAnnotation{
		Filepath: s.Filepath,
		Ident:    req_name,
		File:     s.File,
		Schema:   d.Schema,
	}
	key_fields := []*FieldAnnotation{}
	for _, field := range d.Fields {
		if !field.IsKey {
			continue
		}

		key_fields = append(key_fields, field)
	}

	// Referenced edges and fields are must be a proto field.
	for _, index := range d.Schema.Indexes {
		k, ok := DecodeAnnotation(&KeyAnnotation{}, index.Annotations)
		if !ok {
			continue
		}
		if !index.Unique {
			continue
		}

		sub_msg := &MessageAnnotation{
			Filepath: s.Filepath,
			Ident:    ident.Ident(fmt.Sprintf("Get%s%s", d.Ident, strcase.ToCamel(k.Key))),
			File:     s.File,
			Schema:   d.Schema,
			Fields:   []*FieldAnnotation{},
		}
		for _, field_name := range index.Fields {
			i := slices.IndexFunc(d.Fields, func(f *FieldAnnotation) bool {
				return f.Ident == ident.Ident(field_name)
			})
			if i >= 0 {
				field := d.Fields[i]
				sub_msg.Fields = append(sub_msg.Fields, field)
				continue
			}

			i = slices.IndexFunc(d.Schema.Edges, func(edge *load.Edge) bool {
				return edge.Field == field_name
			})
			if i < 0 {
				panic(fmt.Errorf("index references non-exist field \"%s\"", field_name))
			}
			edge := d.Schema.Edges[i]

			i = slices.IndexFunc(d.Fields, func(f *FieldAnnotation) bool {
				return f.EntName == edge.Name
			})
			field := d.Fields[i]

			ref_msg, ok := p.Schemas[edge.Type]
			if !ok {
				panic(fmt.Sprintf("message of schema \"%s\" not found", edge.Type))
			}

			ref_get_msg := p.buildGetMessage(ref_msg)
			sub_msg.Fields = append(sub_msg.Fields, &FieldAnnotation{
				Ident:  field.Ident,
				Number: field.Number,
				EntMsg: ref_get_msg,
				PbType: ref_get_msg.pbType(),
			})
		}

		key_fields = append(key_fields, &FieldAnnotation{
			Ident:  ident.Ident(k.Key),
			Number: k.Number,
			EntMsg: sub_msg,
			PbType: sub_msg.pbType(),
		})

		s.File.Messages[sub_msg.Ident] = sub_msg
		p.Messages[sub_msg.Ident] = sub_msg
	}

	key_fields = append(key_fields, &FieldAnnotation{
		Ident: "query",
		// Note that this prevents the user from using field 14 as the key field.
		Number:  14,
		EntInfo: &field.TypeInfo{Type: field.TypeString},
		PbType:  pb_types[field.TypeString],
	})

	msg.Fields = append(msg.Fields, &FieldAnnotation{
		Ident: "key",
		Oneof: key_fields,
		Number: slices.MinFunc(key_fields, func(a, b *FieldAnnotation) int {
			return cmp.Compare(a.Number, b.Number)
		}).Number,
	})

	s.File.Messages[req_name] = msg
	p.Messages[req_name] = msg
	return msg
}

// `msg` must be GetXXXRequest
func getSpecifierRestPathEntries(msg *MessageAnnotation, query_prefix string) [][]string {
	if query_prefix != "" {
		query_prefix += "."
	}

	msg.File.Imports["google/api/annotations.proto"] = struct{}{}

	name := strings.ToLower(msg.Schema.Name)
	ps := [][]string{}
	ps = append(ps, []string{name, fmt.Sprintf("{%squery}", query_prefix)})

L:
	for _, k := range msg.Fields[0].Oneof {
		if !k.IsTypeMessage() {
			continue
		}

		p := []string{}
		fields := slices.Clone(k.EntMsg.Fields)
		slices.Reverse(fields)
		for _, field := range fields {
			if !field.IsTypeMessage() {
				p = append(p, name, fmt.Sprintf("{%s%s.%s}", query_prefix, k.Ident, field.Ident))
				continue
			}

			branch_cnt := 0
			for _, sub := range field.EntMsg.Fields[0].Oneof {
				if sub.IsTypeMessage() {
					branch_cnt++
				}
				if branch_cnt > 1 {
					// ramified.
					// How to make path flexibly?
					// How can I decide main branch?
					continue L
				}
			}

			name := strings.ToLower(field.EntMsg.Schema.Name)
			p = append(p, name, fmt.Sprintf("{%s%s.%s.query}", query_prefix, k.Ident, field.Ident))
		}
		if fields[len(fields)-1].IsTypeMessage() {
			p = append(p, name)
		}

		ps = append(ps, p)
	}

	return ps
}

func getSpecifierRestPaths(msg *MessageAnnotation, query_prefix string) []string {
	entries := getSpecifierRestPathEntries(msg, query_prefix)

	ps := []string{}
	for _, v := range entries {
		p := "/" + strings.Join(v, "/")
		ps = append(ps, p)
	}

	return ps
}

// `msg` must be CreateXXXRequest
func getCreateRestPaths(msg *MessageAnnotation) []string {
	msg.File.Imports["google/api/annotations.proto"] = struct{}{}

	name := strings.ToLower(msg.Schema.Name)
	ps := []string{}
	ps = append(ps, fmt.Sprintf("/%s", name))

	edges := []*FieldAnnotation{}
	for _, f := range msg.Fields {
		if !f.IsEdge() {
			continue
		}
		if f.IsOptional {
			continue
		}

		edges = append(edges, f)
	}
	slices.Reverse(edges)
	p := ""
	for _, edge := range edges {
		name := strings.ToLower(edge.EntMsg.Schema.Name)
		p += fmt.Sprintf("/%s/{%s.query}", name, edge.Ident)
	}
	if len(edges) > 0 {
		p += fmt.Sprintf("/%s", name)
		ps = append(ps, p)
	}

	return ps
}
