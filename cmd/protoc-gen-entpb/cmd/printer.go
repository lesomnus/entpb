package cmd

import (
	"fmt"
	"path/filepath"
	"text/template"

	"github.com/iancoleman/strcase"
	"github.com/lesomnus/entpb"
	"github.com/lesomnus/entpb/pbgen/ident"
	"google.golang.org/protobuf/compiler/protogen"
)

type imports struct {
	Ent  protogen.GoImportPath
	Pred protogen.GoImportPath
	Pb   protogen.GoImportPath
}

type Printer struct {
	EntPackage  protogen.GoImportPath // Package generated by Ent.
	ImportPath  protogen.GoImportPath // Where the generated codes will be written.
	PackageName string

	Build  *entpb.Build
	Plugin *protogen.Plugin

	// Path -> File
	GeneratedFiles map[string]*GeneratedFile
}

type GeneratedFile struct {
	*protogen.GeneratedFile
	tpl *template.Template
}

func (f *GeneratedFile) ExecuteTemplate(name string, data any) error {
	return f.tpl.ExecuteTemplate(f, name, data)
}

func (p *Printer) Print() error {
	if err := p.PrintUtils(); err != nil {
		return err
	}
	if err := p.PrintEnum(); err != nil {
		return err
	}

	for _, pb_file := range p.Plugin.Files {
		if !pb_file.Generate {
			continue
		}
		if err := p.PrintService(pb_file); err != nil {
			return err
		}
	}
	return nil
}

func (p *Printer) GetGeneratedFile(filename string, path protogen.GoImportPath) *GeneratedFile {
	fp := filepath.Join(string(path), filename)
	if o, ok := p.GeneratedFiles[fp]; ok {
		return o
	}

	pkg_name := filepath.Base(string(path))

	o := p.Plugin.NewGeneratedFile(fp, path)
	o.Write([]byte(`// Code generated by "protoc-gen-entpb". DO NOT EDIT`))
	o.Write([]byte(fmt.Sprintf("\n\npackage %s\n\n", pkg_name)))
	tpl := p.NewTemplate(o)

	f := &GeneratedFile{o, tpl}
	p.GeneratedFiles[fp] = f
	return f
}

func (p *Printer) GetGeneratedFileByName(name string) *GeneratedFile {
	return p.GetGeneratedFile(fmt.Sprintf("%s.pb.go", name), p.ImportPath)
}

func (p *Printer) PrintUtils() error {
	o := p.GetGeneratedFileByName("utils")
	imports := imports{
		Ent: p.EntPackage,
	}
	if err := o.ExecuteTemplate("utils.go.tpl", imports); err != nil {
		return fmt.Errorf("utils: %w", err)
	}

	return nil
}

func (p *Printer) PrintEnum() error {
	o := p.GetGeneratedFileByName("enum")
	for _, pb_file := range p.Plugin.Files {
		if !pb_file.Generate {
			continue
		}

		for _, pb_enum := range pb_file.Enums {
			var ent_enum *entpb.Enum
			for _, v := range p.Build.Enums {
				if v.Ident != ident.Ident(pb_enum.Desc.Name()) {
					continue
				}

				ent_enum = v
				break
			}
			if ent_enum == nil {
				panic("invalid build state: enum not found")
			}

			if err := o.ExecuteTemplate("enum.go.tpl", struct {
				imports
				EntEnum *entpb.Enum
				PbEnum  *protogen.Enum
			}{
				imports: imports{
					Ent: p.EntPackage,
					Pb:  pb_file.GoImportPath,
				},
				EntEnum: ent_enum,
				PbEnum:  pb_enum,
			}); err != nil {
				return fmt.Errorf("enum: %w", err)
			}
		}
	}

	return nil
}

func (p *Printer) PrintService(pb_file *protogen.File) error {
	imports_ := imports{
		Ent:  p.EntPackage,
		Pred: protogen.GoImportPath(fmt.Sprintf("%s/predicate", string(p.EntPackage))),
		Pb:   pb_file.GoImportPath,
	}

	for _, pb_service := range pb_file.Services {
		service_name := string(pb_service.Desc.Name())
		var ent_service *entpb.Service
		for _, ent_message := range p.Build.Schemas {
			s := ent_message.Service
			if s == nil {
				continue
			}
			if string(s.Ident) != service_name {
				continue
			}

			ent_service = s
			break
		}
		if ent_service == nil {
			return nil
		}

		ctx := struct {
			imports
			PbSvc    *protogen.Service
			PbMethod *protogen.Method
			EntMsg   *entpb.MessageAnnotation
			EntRpc   *entpb.Rpc
		}{
			imports: imports_,
			PbSvc:   pb_service,
			EntMsg:  ent_service.Message,
		}

		o := p.GetGeneratedFileByName(strcase.ToKebab(string(ent_service.Message.Ident)))
		if err := o.ExecuteTemplate("server-struct.go.tpl", ctx); err != nil {
			return fmt.Errorf("server-struct: %w", err)
		}
		if err := o.ExecuteTemplate("constructor.go.tpl", ctx); err != nil {
			return fmt.Errorf("constructor: %w", err)
		}

		for _, pb_method := range pb_service.Methods {
			ent_rpc, ok := ent_service.Rpcs[ident.Ident(pb_method.Desc.Name())]
			if !ok {
				panic("invalid build state: RPC not found")
			}

			ctx.PbMethod = pb_method
			ctx.EntRpc = ent_rpc

			method_name := ident.Ident(pb_method.Desc.Name())
			switch method_name {
			case "Create":
				if err := o.ExecuteTemplate("method-create.go.tpl", ctx); err != nil {
					return fmt.Errorf("method-create: %w", err)
				}

			case "Get":
				if err := o.ExecuteTemplate("method-get.go.tpl", ctx); err != nil {
					return fmt.Errorf("method-get: %w", err)
				}

			case "Update":
				if err := o.ExecuteTemplate("method-update.go.tpl", ctx); err != nil {
					return fmt.Errorf("method-update: %w", err)
				}

			case "Delete":
				if err := o.ExecuteTemplate("method-delete.go.tpl", ctx); err != nil {
					return fmt.Errorf("method-delete: %w", err)
				}

			default:
			}
		}
		if err := o.ExecuteTemplate("to-pb.go.tpl", ctx); err != nil {
			return fmt.Errorf("to-pb: %w", err)
		}
		if msg, ok := p.Build.Messages[ident.Ident(fmt.Sprintf("Get%sRequest", ctx.EntMsg.Ident))]; ok {
			ctx_ := ctx
			ctx_.EntMsg = msg
			if err := o.ExecuteTemplate("get-id.go.tpl", ctx_); err != nil {
				return fmt.Errorf("get-id: %w", err)
			}
			if err := o.ExecuteTemplate("get-specifier.go.tpl", ctx_); err != nil {
				return fmt.Errorf("get-specifier: %w", err)
			}

			o := p.GetGeneratedFile("ent.pb.go", pb_file.GoImportPath)
			if err := o.ExecuteTemplate("get-by.go.tpl", ctx_); err != nil {
				return fmt.Errorf("get-by: %w", err)
			}
		}
	}
	return nil
}
