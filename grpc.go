package entpb

import (
	"embed"
	"fmt"
	"html/template"
	"path/filepath"
	"strings"
	"unicode"

	"github.com/lesomnus/entpb/pbgen/ident"
	"google.golang.org/protobuf/compiler/protogen"
)

var (
	//go:embed grpc-template/*.tpl
	template_files embed.FS
)

type GrpcPrinter struct {
	GrpcPrinterConfig

	Plugin  *protogen.Plugin
	File    *protogen.File
	Service *protogen.Service
}

type GrpcPrinterConfig struct {
	EntPackage string
	ImportPath string
}

type grpcKnownImports struct {
	Ent  string
	Grpc string

	Status string
	Codes  string
}

func (p *GrpcPrinter) Print(b *Build) error {
	if p.ImportPath == "" {
		p.ImportPath = string(p.File.GoImportPath)
	}

	var service *service
	for _, message := range b.messages {
		s := message.Service
		if s == nil {
			continue
		}

		if s.Name != ident.Ident(p.Service.Desc.Name()) {
			continue
		}

		service = s
		break
	}
	if service == nil {
		// Given service is not defined by Ent.
		return nil
	}

	known_imports := grpcKnownImports{
		Ent:  p.GrpcPrinterConfig.EntPackage,
		Grpc: string(p.File.GoImportPath),

		Status: "google.golang.org/grpc/status",
		Codes:  "google.golang.org/grpc/codes",
	}

	import_path := strings.Split(p.ImportPath, "/")
	filename := fmt.Sprintf("%s.pb.go", service.Name)
	filename = snake(filename)
	file_path := filepath.Join(p.ImportPath, filename)
	o := p.Plugin.NewGeneratedFile(file_path, protogen.GoImportPath(p.ImportPath))
	o.Write([]byte(`// Code generated by "protoc-gen-entpb". DO NOT EDIT`))
	o.Write([]byte(fmt.Sprintf("\n\npackage %s\n\n", import_path[len(import_path)-1])))

	tpl := newGrpcTemplate(o)
	if err := tpl.ExecuteTemplate(o, "server-struct.go.tpl", struct {
		grpcKnownImports
		*protogen.Service
	}{
		known_imports,
		p.Service,
	}); err != nil {
		return fmt.Errorf("server-struct: %w", err)
	}
	for _, method := range p.Service.Methods {
		method_name := ident.Ident(method.Desc.Name())
		// rpc, ok := service.Rpcs[method_name]
		// if !ok {
		// 	panic(fmt.Errorf(`unknown RPC: "%s.%s"`, p.Service.Desc.Name(), method.Desc.Name()))
		// }

		// _ = rpc
		// rpc.Req.

		built_in := service.BuiltIn[method_name]
		switch built_in {
		case rpcBuiltInCreate:
		default:
			if err := tpl.ExecuteTemplate(o, "unimplemented-method.go.tpl", struct {
				grpcKnownImports
				Service *protogen.Service
				*protogen.Method
			}{
				known_imports,
				p.Service,
				method,
			}); err != nil {
				return fmt.Errorf("unimplemented-method: %w", err)
			}
		}
	}

	return nil
}

func snake(str string) string {
	var result []rune
	for i, r := range str {
		if unicode.IsUpper(r) {
			// Add an underscore before the uppercase letter (except for the first character)
			if i != 0 {
				result = append(result, '_')
			}
			// Convert the uppercase letter to lowercase
			result = append(result, unicode.ToLower(r))
		} else {
			result = append(result, r)
		}
	}
	return string(result)
}

func newGrpcTemplate(g *protogen.GeneratedFile) *template.Template {
	t := template.New("")
	t.Funcs(template.FuncMap{
		"goident": g.QualifiedGoIdent,
		"ident": func(import_path string, name string) string {
			return g.QualifiedGoIdent(protogen.GoIdent{
				GoName:       name,
				GoImportPath: protogen.GoImportPath(import_path),
			})
		},
	})
	t, err := t.ParseFS(template_files, "grpc-template/*")
	if err != nil {
		panic(err)
	}

	return t
}
