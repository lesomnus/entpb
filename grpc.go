package entpb

import (
	"embed"
	"fmt"
	"path/filepath"
	"strings"
	"text/template"

	"entgo.io/ent/schema/field"
	"github.com/go-openapi/inflect"
	"github.com/lesomnus/entpb/pbgen/ident"
	"github.com/lesomnus/entpb/utils"
	"google.golang.org/protobuf/compiler/protogen"
)

var (
	//go:embed grpc-template/*.tpl
	template_files embed.FS
)

var (
	importRuntime   protogen.GoImportPath = "github.com/lesomnus/entpb/cmd/protoc-gen-entpb/runtime"
	importStatus    protogen.GoImportPath = "google.golang.org/grpc/status"
	importCodes     protogen.GoImportPath = "google.golang.org/grpc/codes"
	importUuid      protogen.GoImportPath = "github.com/google/uuid"
	importTimestamp protogen.GoImportPath = "google.golang.org/protobuf/types/known/timestamppb"
)

type GrpcPrinter struct {
	GrpcPrinterConfig

	Plugin  *protogen.Plugin
	File    *protogen.File
	Service *protogen.Service
}

type GrpcPrinterConfig struct {
	EntPackage string
	ImportPath string
}

type grpcKnownImports struct {
	Ent protogen.GoImportPath
	Pb  protogen.GoImportPath

	Runtime protogen.GoImportPath
}

func (p *GrpcPrinter) Print(b *Build) error {
	if p.ImportPath == "" {
		p.ImportPath = string(p.File.GoImportPath)
	}

	var service *service
	for _, message := range b.messages {
		s := message.Service
		if s == nil {
			continue
		}

		if s.Name != ident.Ident(p.Service.Desc.Name()) {
			continue
		}

		service = s
		break
	}
	if service == nil {
		// Given service is not defined by Ent.
		return nil
	}

	known_imports := grpcKnownImports{
		Ent: protogen.GoImportPath(p.GrpcPrinterConfig.EntPackage),
		Pb:  p.File.GoImportPath,

		Runtime: importRuntime,
	}

	import_path := strings.Split(p.ImportPath, "/")
	filename := fmt.Sprintf("%s.pb.go", service.Name)
	filename = utils.Snake(filename)
	file_path := filepath.Join(p.ImportPath, filename)
	o := p.Plugin.NewGeneratedFile(file_path, protogen.GoImportPath(p.ImportPath))
	o.Write([]byte(`// Code generated by "protoc-gen-entpb". DO NOT EDIT`))
	o.Write([]byte(fmt.Sprintf("\n\npackage %s\n\n", import_path[len(import_path)-1])))

	tpl := newGrpcTemplate(o)
	if err := tpl.ExecuteTemplate(o, "server-struct.go.tpl", struct {
		grpcKnownImports
		*protogen.Service
	}{
		known_imports,
		p.Service,
	}); err != nil {
		return fmt.Errorf("server-struct: %w", err)
	}
	for _, method := range p.Service.Methods {
		method_name := ident.Ident(method.Desc.Name())
		// rpc, ok := service.Rpcs[method_name]
		// if !ok {
		// 	panic(fmt.Errorf(`unknown RPC: "%s.%s"`, p.Service.Desc.Name(), method.Desc.Name()))
		// }

		// _ = rpc
		// rpc.Req.

		built_in := service.BuiltIn[method_name]
		switch built_in {
		case rpcBuiltInUnspecified:
		case rpcBuiltInCreate:
			if err := tpl.ExecuteTemplate(o, "method-create.go.tpl", struct {
				grpcKnownImports
				Service *protogen.Service
				Method  *protogen.Method
				Message *messageAnnotation
			}{
				known_imports,
				p.Service,
				method,
				service.message,
			}); err != nil {
				return fmt.Errorf("method-create: %w", err)
			}

		default:
		}
	}
	if err := tpl.ExecuteTemplate(o, "to-pb.go.tpl", struct {
		grpcKnownImports
		*messageAnnotation
	}{
		known_imports,
		service.message,
	}); err != nil {
		return fmt.Errorf("to-pb: %w", err)
	}

	return nil
}

func newGrpcTemplate(g *protogen.GeneratedFile) *template.Template {
	t := template.New("")
	t.Funcs(template.FuncMap{
		"singular": inflect.Singularize,
		"pascal":   utils.Pascal,
		"entname": func(name string) string {
			// FIXME: I don't know how Ent make acronym from the arbitrary input
			// but current example only have this so I hard-coded it.
			if name == "id" {
				return "ID"
			}
			return utils.Pascal(name)
		},
		"goident": g.QualifiedGoIdent,
		"ident": func(import_path protogen.GoImportPath, name string) string {
			return g.QualifiedGoIdent(protogen.GoIdent{
				GoName:       name,
				GoImportPath: import_path,
			})
		},
		"to_ent": func(f *fieldAnnotation, ident_in string, ident_out string, body string) string {
			var t field.Type
			if f.IsEdge() {
				t = field.TypeUUID
			} else {
				t = f.EntType.Type
			}
			b := strings.ReplaceAll(body, "@", ident_out)
			switch t {
			case field.TypeUUID:
				r := strings.NewReplacer(
					"$i", ident_in,
					"$o", ident_out,
					"$body", b,
					"$uuid", g.QualifiedGoIdent(importUuid.Ident("FromBytes")),
					"$status", g.QualifiedGoIdent(importStatus.Ident("Errorf")),
					"$code", g.QualifiedGoIdent(importCodes.Ident("InvalidArgument")),
					"$name", string(f.Ident),
				)
				return r.Replace(
					`if $o, err := $uuid($i); err != nil {
						return nil, $status($code, "$name: %s", err)
					} else {
						$body
					}`)
			case field.TypeTime:
				return fmt.Sprintf("%s := %s.AsTime()\n%s", ident_out, ident_in, b)

			default:
				return strings.ReplaceAll(body, "@", ident_in)
			}
		},
		"to_pb": func(f *fieldAnnotation, ident_in string) string {
			t := f.EntType.Type
			switch t {
			case field.TypeUUID:
				return fmt.Sprintf("%s[:]", ident_in)
			case field.TypeTime:
				return fmt.Sprintf("%s(%s)", g.QualifiedGoIdent(importTimestamp.Ident("New")), ident_in)
			default:
				return ident_in
			}
		},
	})
	t, err := t.ParseFS(template_files, "grpc-template/*")
	if err != nil {
		panic(err)
	}

	return t
}
